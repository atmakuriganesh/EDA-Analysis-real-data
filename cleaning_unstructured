# Create a new dictionary for transformed dataframes
transformed_dataframes = {}

for key, df in dataframes_1.items():
    # Make a copy of the original dataframe
    df_copy = df.copy()
    
    # Find the row index that contains header information
    header_row = None
    for idx, row in df_copy.iterrows():
        row_str = [str(x).upper() for x in row.values if not pd.isna(x)]
        if 'OLD GRADE' in row_str or 'STEP' in row_str:
            header_row = idx
            break
    
    if header_row is not None:
        # Get the column positions for each target field
        headers = df_copy.iloc[header_row]
        
        # Create a new dataframe with the proper structure
        new_df = pd.DataFrame(columns=['OLD GRADE', 'CURRENT GRADE', 'STEP', 'ANNUAL', 'category'])
        
        # Define a map to find our columns
        col_positions = {}
        for i, val in enumerate(headers):
            if pd.isna(val):
                continue
            val_str = str(val).upper()
            if 'OLD GRADE' in val_str or val_str == 'OLD':
                col_positions['OLD GRADE'] = i
            elif 'CURRENT GRADE' in val_str or val_str == 'CURRENT':
                col_positions['CURRENT GRADE'] = i
            elif val_str == 'STEP':
                col_positions['STEP'] = i
            elif 'ANNUAL' in val_str:
                col_positions['ANNUAL'] = i  # Will keep the last one
        
        # Process each data row after the header
        for i in range(header_row + 1, len(df_copy)):
            row = df_copy.iloc[i]
            
            # Skip if all values are NaN
            if row.isna().all():
                continue
                
            new_row = {'category': key}
            for col_name, position in col_positions.items():
                if position < len(row):
                    new_row[col_name] = row.iloc[position]
            
            # Add this row to our new dataframe
            new_df = pd.concat([new_df, pd.DataFrame([new_row])], ignore_index=True)
        
        transformed_dataframes[key] = new_df
    else:
        # Create an empty dataframe if no header row found
        transformed_dataframes[key] = pd.DataFrame(columns=['OLD GRADE', 'CURRENT GRADE', 'STEP', 'ANNUAL', 'category'])

# Update the original dictionary
dataframes_1 = transformed_dataframes

# Check if we have data in the transformed dataframes
for key, df in dataframes_1.items():
    print(f"\nDataframe: {key}")
    print(f"Shape: {df.shape}")
    if not df.empty:
        print(df.head(3))
    else:
        print("Empty dataframe")
