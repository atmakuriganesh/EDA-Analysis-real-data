import pandas as pd

def extract_rxg_data(df_input, category_name=None):
    """
    Extract RXG data from a DataFrame, using the Annual row for the end_rate.
    
    Parameters:
    df_input (pandas.DataFrame): Input DataFrame
    category_name (str): Name to use for the category column
    
    Returns:
    pandas.DataFrame: DataFrame with grade, term, end_rate and category columns
    """
    # Reset index and ensure consistent format
    df_raw = df_input.reset_index(drop=True)
    
    # If no category name provided, try to extract it from the data
    if not category_name:
        for i in range(min(5, df_raw.shape[0])):
            for j in range(min(5, df_raw.shape[1])):
                if i < df_raw.shape[0] and j < df_raw.shape[1]:
                    cell_value = str(df_raw.iloc[i, j])
                    if "STEP" in cell_value.upper():
                        category_name = "RXG Pay Structure"
                        break
        # Default if not found
        if not category_name:
            category_name = "RXG Pay Structure"
    
    data = []
    target_dates = ['6/1/2023', '6/1/23']
    found_date_row = None
    
    # First, find the row with the target date
    for i in range(df_raw.shape[0]):
        if df_raw.shape[1] <= 1:
            continue
            
        for j in range(2):  # Check first two columns
            if j < df_raw.shape[1]:
                date_cell = str(df_raw.iloc[i, j]).strip()
                
                # Check if this cell contains a target date
                if any(date_str in date_cell for date_str in target_dates):
                    found_date_row = i
                    break
                else:
                    try:
                        date_obj = pd.to_datetime(date_cell, errors='raise')
                        if date_obj.month == 6 and date_obj.day == 1 and date_obj.year == 2023:
                            found_date_row = i
                            break
                    except:
                        pass
        
        if found_date_row is not None:
            break
    
    # If we found a date row, look for Annual in the next few rows
    if found_date_row is not None:
        grade = None
        
        # Get the grade (RXG) from the first column
        if df_raw.shape[1] > 0:
            grade = str(df_raw.iloc[found_date_row, 0]).strip()
        
        # Look for "Annual" in column 1 within the next 3 rows
        for i in range(found_date_row, min(found_date_row + 3, df_raw.shape[0])):
            if df_raw.shape[1] > 1:
                term_cell = str(df_raw.iloc[i, 1]).strip()
                
                if term_cell.lower() == 'annual':
                    # Get the annual rate from column 2
                    if df_raw.shape[1] > 2:
                        annual_str = str(df_raw.iloc[i, 2])
                        
                        try:
                            # Clean and convert to float
                            annual_str = annual_str.replace('$', '').replace(',', '')
                            annual_rate = float(annual_str)
                            
                            data.append({
                                'grade': grade,
                                'term': 'annual',
                                'end_rate': round(annual_rate, 2),
                                'category': category_name
                            })
                            break  # We found what we needed
                        except ValueError:
                            pass  # Skip if can't convert
    
    result_df = pd.DataFrame(data)
    
    # Drop any rows with NaN end_rates
    if not result_df.empty:
        result_df = result_df.dropna(subset=['end_rate'])
    
    return result_df

# Example usage:
# df_result = extract_rxg_data(df['as'], "RXG Pay Structure")
