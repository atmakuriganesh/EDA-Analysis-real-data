import pandas as pd
import numpy as np

def inspect_and_extract_rxg_data(df_input, category_name=None):
    """
    First inspects the dataframe content, then extracts RXG data.
    
    Parameters:
    df_input (pandas.DataFrame): Input DataFrame
    category_name (str): Name to use for the category column
    
    Returns:
    pandas.DataFrame: DataFrame with grade, term, end_rate and category columns
    """
    # Reset index and ensure consistent format
    df_raw = df_input.reset_index(drop=True)
    
    # If no category name provided, use default
    if not category_name:
        category_name = "RXG Pay Structure"
    
    print(f"Using category: {category_name}")
    print(f"DataFrame shape: {df_raw.shape}")
    
    # First, scan and print any content that might contain target values
    print("\n--- INSPECTION PHASE ---")
    found_rxg = False
    found_2023 = False
    found_annual = False
    
    # Print all non-empty cells that might be relevant
    for i in range(df_raw.shape[0]):
        row_content = []
        for j in range(min(df_raw.shape[1], 5)):
            if j < df_raw.shape[1]:
                value = df_raw.iloc[i, j]
                if pd.notna(value) and str(value).strip() and str(value).strip() != 'nan':
                    str_val = str(value).strip()
                    row_content.append(f"Col{j}='{str_val}'")
                    
                    # Track if we found key items
                    if 'RXG' in str_val:
                        found_rxg = True
                    if '2023' in str_val or '/1/23' in str_val or '/1/2023' in str_val:
                        found_2023 = True
                    if 'annual' in str_val.lower():
                        found_annual = True
        
        if row_content:
            print(f"Row {i}: {', '.join(row_content)}")
    
    print(f"\nFound RXG: {found_rxg}")
    print(f"Found 2023: {found_2023}")
    print(f"Found Annual: {found_annual}")
    
    # For dates stored as datetime objects, print specifically
    print("\n--- CHECKING DATE OBJECTS ---")
    date_rows = []
    for i in range(df_raw.shape[0]):
        for j in range(min(df_raw.shape[1], 5)):
            if j < df_raw.shape[1]:
                value = df_raw.iloc[i, j]
                if isinstance(value, (pd.Timestamp, np.datetime64)) or (
                    isinstance(value, str) and ('/' in value or '-' in value)):
                    print(f"Row {i}, Col{j}: Date-like value = '{value}'")
                    if '2023' in str(value) or pd.to_datetime(str(value), errors='coerce') is not pd.NaT:
                        try:
                            date_obj = pd.to_datetime(value)
                            if date_obj.year == 2023 and date_obj.month == 6 and date_obj.day == 1:
                                print(f"  ✓ MATCH: Found June 1, 2023 date")
                                date_rows.append(i)
                        except:
                            if '2023' in str(value) and ('6/1' in str(value) or '6-1' in str(value)):
                                print(f"  ✓ MATCH: Found June 1, 2023 date by string")
                                date_rows.append(i)
    
    # Now extract data based on our findings
    print("\n--- EXTRACTION PHASE ---")
    data = []
    
    # If we found date rows
    if date_rows:
        for date_row in date_rows:
            print(f"Processing date row {date_row}")
            
            # Find grade (RXG)
            grade = None
            # Check current and previous row
            for row_idx in [date_row, date_row-1]:
                if 0 <= row_idx < df_raw.shape[0]:
                    for j in range(min(df_raw.shape[1], 3)):
                        value = str(df_raw.iloc[row_idx, j]).strip()
                        if 'RXG' in value:
                            grade = 'RXG'
                            print(f"Found grade '{grade}' in row {row_idx}, col {j}")
                            break
                    if grade:
                        break
            
            # Default to RXG if not found
            if not grade:
                grade = 'RXG'
                print(f"Using default grade '{grade}'")
            
            # Find Annual values
            annual_rate = None
            found_annual_row = False
            
            # Look up to 4 rows after the date row
            for row_idx in range(date_row, min(date_row+5, df_raw.shape[0])):
                for j in range(min(df_raw.shape[1], 5)):
                    value = str(df_raw.iloc[row_idx, j]).strip().lower()
                    if 'annual' in value:
                        print(f"Found 'Annual' in row {row_idx}, col {j}")
                        found_annual_row = True
                        
                        # Look for a numeric value in this row
                        for k in range(min(df_raw.shape[1], 5)):
                            if k != j:
                                rate_value = str(df_raw.iloc[row_idx, k]).strip()
                                if rate_value and rate_value != 'nan':
                                    try:
                                        rate_value = rate_value.replace('$', '').replace(',', '')
                                        annual_rate = float(rate_value)
                                        print(f"Found annual rate {annual_rate} in row {row_idx}, col {k}")
                                        break
                                    except:
                                        pass
                        break
                if found_annual_row:
                    break
            
            # If we found an annual rate, add to results
            if annual_rate:
                data.append({
                    'grade': grade,
                    'term': 'annual',
                    'end_rate': round(annual_rate, 2),
                    'category': category_name
                })
                print(f"Added record: {grade}, annual, {annual_rate}, {category_name}")
    
    # If still no data, try another approach - look specifically for Annual values
    if not data:
        print("\n--- TRYING ALTERNATIVE APPROACH ---")
        for i in range(df_raw.shape[0]):
            for j in range(min(df_raw.shape[1], 5)):
                if j < df_raw.shape[1]:
                    value = str(df_raw.iloc[i, j]).strip().lower()
                    if value == 'annual':
                        print(f"Found 'Annual' in row {i}, col {j}")
                        
                        # Check for annual rate in this row
                        found_rate = False
                        for k in range(min(df_raw.shape[1], 5)):
                            if k != j:
                                rate_value = str(df_raw.iloc[i, k]).strip()
                                if rate_value and rate_value != 'nan':
                                    try:
                                        rate_value = rate_value.replace('$', '').replace(',', '')
                                        annual_rate = float(rate_value)
                                        print(f"Found annual rate {annual_rate} in row {i}, col {k}")
                                        
                                        # Look for a '2023' indicator in nearby rows
                                        found_2023 = False
                                        for row_idx in range(max(0, i-3), i+1):
                                            for col_idx in range(min(df_raw.shape[1], 5)):
                                                cell_value = str(df_raw.iloc[row_idx, col_idx])
                                                if '2023' in cell_value or '/23' in cell_value:
                                                    found_2023 = True
                                                    print(f"Found 2023 indicator in row {row_idx}, col {col_idx}")
                                                    break
                                            if found_2023:
                                                break
                                        
                                        if found_2023:
                                            data.append({
                                                'grade': 'RXG',  # Default to RXG
                                                'term': 'annual',
                                                'end_rate': round(annual_rate, 2),
                                                'category': category_name
                                            })
                                            print(f"Added record: RXG, annual, {annual_rate}, {category_name}")
                                            found_rate = True
                                            break
                                    except:
                                        pass
                        if found_rate:
                            break
    
    print(f"\nTotal records found: {len(data)}")
    result_df = pd.DataFrame(data)
    
    return result_df

# Example usage:
# df_result = inspect_and_extract_rxg_data(df['6.1.2021-25'], "1ST STEP")
